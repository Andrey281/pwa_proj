# Service Worker (sw.js) - Подробное описание

## Что такое Service Worker?

Service Worker - это JavaScript-файл, который работает **в фоновом режиме** отдельно от веб-страницы. Он позволяет приложению работать **офлайн**, кэшировать ресурсы и показывать push-уведомления.

**Ключевые особенности:**
- Работает в отдельном потоке (не блокирует основной поток)
- Может работать даже когда сайт закрыт
- Имеет доступ к кэшу браузера
- Может перехватывать сетевые запросы

---

## Структура Service Worker

### Константы

```javascript
const CACHE_NAME = 'gogo-pizza-v6';
const urlsToCache = [
    '/',
    '/index.html',
    '/manifest.json',
    '/pwa-icon.svg'
];
```

- **CACHE_NAME** - имя кэша (версия меняется при обновлении)
- **urlsToCache** - список ресурсов для кэширования при установке

---

## События Service Worker

### 1. Событие `install` - Установка

**Когда срабатывает:**
- При первой регистрации Service Worker
- При обновлении Service Worker (когда файл изменен)

**Что происходит:**

```javascript
self.addEventListener('install', (event) => {
    // 1. Открываем кэш
    caches.open(CACHE_NAME)
        .then((cache) => {
            // 2. Кэшируем основные ресурсы
            cache.addAll(urlsToCache);
        });
    
    // 3. Немедленно активируем новый Service Worker
    self.skipWaiting();
});
```

**Результат:**
- Создается кэш `gogo-pizza-v6`
- В кэш сохраняются основные файлы
- Новый Service Worker активируется сразу (не ждет закрытия всех вкладок)

---

### 2. Событие `activate` - Активация

**Когда срабатывает:**
- После установки, когда Service Worker готов взять контроль

**Что происходит:**

```javascript
self.addEventListener('activate', (event) => {
    // 1. Получаем список всех кэшей
    caches.keys()
        .then((cacheNames) => {
            // 2. Удаляем старые кэши (v1, v2, v3, v4, v5)
            cacheNames.forEach(cacheName => {
                if (cacheName !== CACHE_NAME) {
                    caches.delete(cacheName);
                }
            });
        });
    
    // 3. Берем контроль над всеми открытыми вкладками
    return self.clients.claim();
});
```

**Результат:**
- Удаляются старые версии кэша
- Service Worker контролирует все открытые страницы

---

### 3. Событие `fetch` - Перехват запросов

**Когда срабатывает:**
- При каждом запросе ресурса (HTML, JS, CSS, изображения, API)

**Стратегия: Network First (Сначала сеть, потом кэш)**

#### Для HTML документов (страницы):

```javascript
if (event.request.mode === 'navigate' || 
    event.request.destination === 'document') {
    
    // 1. Пытаемся загрузить из сети
    fetch(event.request)
        .then((response) => {
            // 2. Если успешно - кэшируем
            cache.put('/index.html', response);
            return response;
        })
        .catch(() => {
            // 3. Если офлайн - возвращаем из кэша
            return caches.match('/index.html');
        });
}
```

**Логика:**
1. Сначала пытается загрузить свежую версию из сети
2. Если успешно - сохраняет в кэш
3. Если офлайн - возвращает из кэша
4. Если нет в кэше - возвращает базовый HTML

#### Для остальных ресурсов (JS, CSS, изображения):

```javascript
// 1. Пытаемся загрузить из сети
fetch(event.request)
    .then((response) => {
        // 2. Кэшируем успешные ответы
        if (response.status === 200) {
            cache.put(event.request, response);
        }
        return response;
    })
    .catch(() => {
        // 3. Если офлайн - ищем в кэше
        return caches.match(event.request, { ignoreSearch: true })
            .then((cached) => {
                if (cached) {
                    return cached; // Нашли в кэше
                }
                
                // 4. Если не нашли - возвращаем заглушку
                // Для JS - пустой код
                // Для CSS - пустой стиль
                // Для изображений - ошибка 404
            });
    });
```

**Особенности:**
- `ignoreSearch: true` - игнорирует query-параметры (важно для Vite)
- Для JS файлов возвращается пустой код, а не HTML (защита от ошибок)
- Все ресурсы автоматически кэшируются при первом посещении

---

## Push-уведомления

### Событие `push`

**Когда срабатывает:** При получении push-уведомления от сервера

```javascript
self.addEventListener('push', (event) => {
    // Показываем нативное уведомление ОС
    self.registration.showNotification('Gogo Пицца', {
        body: 'Текст уведомления',
        icon: '/pwa-icon.svg',
        vibrate: [200, 100, 200],
        // ...
    });
});
```

**Результат:** Пользователь видит уведомление даже когда сайт закрыт

### Событие `notificationclick`

**Когда срабатывает:** При клике на уведомление

```javascript
self.addEventListener('notificationclick', (event) => {
    // Закрываем уведомление
    event.notification.close();
    
    // Открываем/фокусируем приложение
    clients.openWindow('/');
});
```

---

## Сообщения от клиента

### Событие `message`

**Когда срабатывает:** Когда React-приложение отправляет сообщение Service Worker

```javascript
self.addEventListener('message', (event) => {
    // Команда на обновление
    if (event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }
    
    // Команда на показ уведомления
    if (event.data.type === 'SHOW_NOTIFICATION') {
        self.registration.showNotification(title, options);
    }
});
```

**Использование:**
- React-компонент отправляет команду через `navigator.serviceWorker.controller.postMessage()`
- Service Worker выполняет действие (показывает уведомление, обновляется)

---

## Фоновая синхронизация

### Событие `sync`

**Когда срабатывает:** При появлении интернета после офлайн периода

```javascript
self.addEventListener('sync', (event) => {
    if (event.tag === 'sync-orders') {
        // Синхронизируем заказы, сделанные офлайн
    }
});
```

**Использование:** Для отправки данных, сохраненных локально во время офлайн режима

---

## Как это работает в приложении Gogo Пицца

### 1. Первое посещение (с интернетом):

1. Service Worker регистрируется
2. Кэшируются основные файлы (`index.html`, `manifest.json`)
3. При загрузке страницы все ресурсы кэшируются автоматически
4. Приложение работает нормально

### 2. Повторное посещение (с интернетом):

1. Service Worker перехватывает запросы
2. Сначала пытается загрузить из сети (свежие версии)
3. Кэширует обновленные ресурсы
4. Приложение работает быстро (часть ресурсов из кэша)

### 3. Офлайн режим:

1. Service Worker перехватывает запросы
2. Не может загрузить из сети
3. Возвращает ресурсы из кэша
4. Приложение работает полностью офлайн!

### 4. Push-уведомления:

1. React-компонент отправляет сообщение Service Worker
2. Service Worker показывает нативное уведомление
3. Работает даже когда сайт закрыт

---

## Важные детали реализации

### 1. Игнорирование query-параметров

```javascript
caches.match(event.request, { ignoreSearch: true })
```

**Зачем:** Vite добавляет query-параметры к файлам (`main.js?t=123456`). Без `ignoreSearch` файл не найдешь в кэше, если параметр изменился.

### 2. Защита от возврата HTML для JS

```javascript
// Если JS файл не найден в кэше
return new Response('console.warn("Resource offline");', {
    headers: { 'Content-Type': 'application/javascript' }
});
```

**Зачем:** Если вернуть HTML вместо JS, браузер выдаст ошибку `SyntaxError: Unexpected token '<'`.

### 3. Автоматическое кэширование

Все успешные запросы автоматически сохраняются в кэш:

```javascript
if (response.status === 200) {
    cache.put(event.request, response.clone());
}
```

**Результат:** При первом посещении все ресурсы кэшируются, при втором - загружаются из кэша.

---

## Связь Service Worker с PWA

### Что такое PWA?

PWA (Progressive Web App) = **Web App Manifest** + **Service Worker** + **HTTPS**

Для того, чтобы приложение считалось PWA, нужно:

1. ✅ **Web App Manifest** (`manifest.json`) - определяет метаданные приложения
2. ✅ **Service Worker** (`sw.js`) - обеспечивает офлайн работу и кэширование
3. ✅ **HTTPS** (или localhost) - обязательное требование безопасности

### Как Service Worker связан с PWA?

Service Worker - это **обязательный компонент PWA**. Без него приложение не может:
- Работать офлайн
- Быть установленным (один из критериев установки)
- Показывать push-уведомления в фоне
- Кэшировать ресурсы для быстрой загрузки

**Service Worker = основа PWA функционала!**

---

## Установка приложения: Что меняется?

### Без установки (просто сайт в браузере):

✅ **Service Worker работает:**
- Кэширует ресурсы
- Работает офлайн
- Показывает уведомления (когда вкладка открыта)
- Быстрая загрузка из кэша

❌ **Ограничения:**
- Нет иконки на рабочем столе
- Открывается в браузере (с адресной строкой)
- Уведомления работают только когда вкладка открыта
- Нет standalone режима

### С установкой (PWA приложение):

✅ **Все возможности Service Worker:**
- Кэширует ресурсы
- Работает офлайн
- Показывает уведомления (даже когда закрыто!)
- Быстрая загрузка из кэша

✅ **Дополнительные возможности:**
- Иконка на рабочем столе/домашнем экране
- Открывается как нативное приложение (без адресной строки)
- Уведомления работают **даже когда приложение закрыто**
- Standalone режим (полноэкранный)
- Быстрый доступ через ярлык

---

## Разница в работе уведомлений

### Без установки:
```javascript
// Уведомления работают только когда вкладка открыта
const notification = new Notification('Заголовок', options);
// Если закрыть вкладку - уведомления перестанут работать
```

### С установкой (через Service Worker):
```javascript
// Уведомления работают даже когда приложение закрыто
navigator.serviceWorker.controller.postMessage({
    type: 'SHOW_NOTIFICATION',
    title: 'Заголовок',
    options: { ... }
});
// Service Worker показывает уведомление в фоне
```

---

## Итого

Service Worker в приложении Gogo Пицца обеспечивает:

✅ **Офлайн работу** - приложение работает без интернета  
✅ **Быструю загрузку** - ресурсы загружаются из кэша  
✅ **Push-уведомления** - работают в фоне  
✅ **Автоматическое обновление** - кэш обновляется при наличии сети  

### Связь с PWA:

- **Service Worker** - обязательный компонент PWA
- Без Service Worker приложение **не может быть установлено**
- Service Worker работает **и без установки**, но с ограничениями
- **С установкой** получаете все возможности PWA (standalone режим, уведомления в фоне, иконка на рабочем столе)

**Вывод:** Service Worker работает всегда, но установка приложения дает дополнительные возможности!

